## redis提供的策略
### 内存回收(碎片回收)
> redis会自身对内存开启回收,常见的SDS的缩小后的内存,过期key等等情况发生,需要配置一些额外的参数即可
### 过期策略
noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧

allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）

allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧

volatile-lfu：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）

volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key

volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除
抛出一个问题,手写lru算法？ 试一试

### 删除策略
定时删除+惰性删除
- 惰性删除
当使用到这个key的时候,判断当前这个key是否已经过期。 如果过期了就从过期字典中删除

- 定期删除策略
例如每10s开始遍历 1号库开始遍历,随机取值判断

## 业务场景中需要注意的点

### 为什么redis命令一会快一会慢

- 排查是否属于网络问题 网络延迟 redis-cli -h 127.0.0.1 -p 6379 --intrinsic-latency 60

- 查询redis的慢日志
通过慢日志反查业务逻辑,清理掉异常的行为逻辑
- key的集中过期,如果其中包含大key的过期,触发key的删除策略
- 实例内存达到上限   会启动自动回收的策略, 这个时候在执行redis的指令前。会提前执行内存回收,这个操作会带来延迟。
- RDB+AOF 为了保证数据的安全性和持久性。当在执行bgsave的时候，RDB会使用COW的技术,copy一份内存页。如果这个时候内存本身也不够用了,redis实例就会被阻塞 无法处理任何请求
- 如果此时你的 CPU 资源本来就很紧张，那么 fork 的耗时会更长，甚至达到秒级，这会严重影响 Redis 的性能。
- SWAP技术  将内存中的数据缓存到磁盘上, 这个时候考虑增大内存. 重启实例等等操作,释放掉占用的swap空间
ps -aux | grep redis-server
-  查看 Redis Swap 使用情况
cat /proc/$pid/smaps | egrep '^(Swap|Size)'
### DEL 竟然也会阻塞 Redis？
del命令 会取决于要删除的key的类型跟value的长度
1. 查询元素数量：执行 LLEN/HLEN/SCARD/ZCARD 命令
2. 判断元素数量：如果元素数量较少，可直接执行 DEL 删除，否则分批删除
3. 分批删除：执行 LRANGE/HSCAN/SSCAN/ZSCAN + LPOP/RPOP/HDEL/SREM/ZREM 删除
   如果这个key是一个大key, 删除的时候的时候也会有可能阻塞. 删除的行为会阻塞其他线程的操作

### 主从复制的坑
可能会存在丢数据的情况发生

如果你把 Redis 当做纯缓存来使用，那对业务来说没有什么影响。
master 未同步到 slave 的数据，业务应用可以从后端数据库中重新查询到。
但是，对于把 Redis 当做数据库，或是当做分布式锁来使用的业务，有可能因为异步复制的问题，导致数据丢失 / 锁丢失。


### 缓存一致性的问题

1 非实时一致
插入是对DB的修改
查询是对redis的操作, 通过定时器的方式将修改完的数据同步到缓存中

2 实时一致
先更新数据库 再删除缓存

推荐采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做。

如果数据库是主从模型的架构 还需要考虑使用延时双删的策略
