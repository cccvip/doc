推荐周志明老师的深入理解JAVA虚拟机,里面的知识,对于CRUD的开发可能不需要,但是对于线上排查问题,以及线上调优就显得尤其重要。

## 基础概念

> 堆栈,内存模型,直接内存,方法区永久代等基本东西参考书即可

## 盲点(好运不会眷顾傻瓜)

> 容易被忽视的点,也常常是面试中的必考点

### safePoint(安全点)跟stw

> safePoint是一种机制,例如在gc的时候,必须等到所有工作线程都到达safePoint,才能进行gc。而在这个过程会形成stw的现象。

再想一下,安全点到底应该如何选择?
- 循环的末尾
- 方法临返回前
- 调用方法之后
- 抛异常的位置

主要的目的就是避免程序长时间无法进入 Safe Point。比如 JVM 在做 GC 之前要等所有的应用线程进入安全点，如果有一个线程一直没有进入安全点，就会导致 GC 时 JVM 停顿时间延长。但是超大的循环导致执行 GC 等待时间过长


如何在 GC 发生时，所有线程都跑到最近的 Safe Point 上再停下来？
> JVM 采取的就是主动式中断。轮询标志的地方和安全点是重合的。

安全区域

> 安全区域是指一段代码片段之中，引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。


## 堆

### 新生代和老年代

#### 概念(略)

#### 新生代(edgen,s0,s1)

s0跟s1是保留上次gc后没有被清掉的对象,一个暂时存放的地址。随着年龄的增大,年轻代的对象都将会被放置到老年区。

算法:
minorGc是使用复制算法

#### 老年代
> 朝生夕死的年轻对象,经过多次15GC后依然存活,就会被放入到老年代中。

- 分配担保
> 如果对象>年轻代的2分之一,即使发生过young GC之后,内存依旧不足。这个时候的对象就会进入老年代。

算法:
标记清楚


### 聊聊元空间

JAVA8之后,使用本地内存存放CLASS对象等元数据对象。而字符串串跟类的静态变量(static final修饰),放入堆中



## 垃圾回收算法

### 实现方式

> 复制,标记清楚,标记整理,分代等

### CMS垃圾收集器(重点)
> 作用于老年代

流程如下
- 初始标记:对GC ROOT直接引用的对象做一个标记
- 并发标记:对堆里的所有引用对象全部找到并做标记
- 重新标记:CMS会触发STW机制，并修复并发标记状态已经改变的对象
- 并发清除:对没有被做标记的对象进行一个清理回收

优势:
> 清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并
  发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看
  CMS 收集器的内存回收和用户线程是一起并发地执行

问题:

> 标记清除算法本身的问题:会产生内存碎片, 需要进行内存整理

> 浮动垃圾: gc线程跟用户线程是一起执行的,一定会存在浮动垃圾的产生

> 当我们的老年代内存空间满了之后，虽然这时候在做FULL GC，但是在FULL GC的过程中有一个新的对象进来了怎么办？
  此时会进入STW状态，并且CMS会自动切换到用Serial old垃圾收集器来回收。Serial我们都知道，它是一个单线程的垃圾回收器。那这种情况出现是不是会严重降低我们的执行效率？
  那么我们为了解决这个问题，可以通过调整老年代空间被占满了多少之后触发FULL GC -XX:CMSInitiatingOccupancyFraction 参数如上，通过这个参数可以调整触发full gc的百分比,默认是92%

[参考地址](https://blog.csdn.net/weixin_32126843/article/details/114084339)

### G1垃圾收集器(可能是重点)

老实讲没用过,只能看书上的概念瞧个新鲜,如果被问到相关的内容,我会怎么答?

基础模型不一样

G1是用分区(region),有别于传统的分代模型。固定的分区8:2(新:老)。G1的每一个区可能是s区,edgen,老年代等

算法:
年轻代:复制算法
年老代:标记整理算法(CMS)

优势:
G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域
的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾
最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收
集效率。


#### 三色标记法

> 可达性分析法中的一种具体实现,学golang(Version.1.13)的时候,发现两者gc算法异曲同工。 了解了解就好,倒不用太刻意关注






















